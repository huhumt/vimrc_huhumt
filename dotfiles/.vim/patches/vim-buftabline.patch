diff --git a/plugin/buftabline.vim b/plugin/buftabline.vim
index fccfd6d..4a47a02 100644
--- a/plugin/buftabline.vim
+++ b/plugin/buftabline.vim
@@ -2,17 +2,17 @@
 " Licence:     The MIT License (MIT)
 " Commit:      $Format:%H$
 " {{{ Copyright (c) 2015 Aristotle Pagaltzis <pagaltzis@gmx.de>
-" 
+"
 " Permission is hereby granted, free of charge, to any person obtaining a copy
 " of this software and associated documentation files (the "Software"), to deal
 " in the Software without restriction, including without limitation the rights
 " to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 " copies of the Software, and to permit persons to whom the Software is
 " furnished to do so, subject to the following conditions:
-" 
+"
 " The above copyright notice and this permission notice shall be included in
 " all copies or substantial portions of the Software.
-" 
+"
 " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -29,9 +29,13 @@ endif
 
 scriptencoding utf-8
 
-hi default link BufTabLineCurrent         TabLineSel
-hi default link BufTabLineActive          PmenuSel
-hi default link BufTabLineHidden          TabLine
+" https://www.ditig.com/256-colors-cheat-sheet
+highlight BufTabLineTabPad                       ctermbg=235   ctermfg=76
+highlight BufTabLineBufnum    cterm=bold         ctermbg=142   ctermfg=126
+highlight BufTabLineCurrent   cterm=underline    ctermbg=11    ctermfg=242
+highlight BufTabLineActive                       ctermbg=12    ctermfg=120
+highlight BufTabLineHidden                       ctermbg=239   ctermfg=223
+
 hi default link BufTabLineFill            TabLineFill
 hi default link BufTabLineModifiedCurrent BufTabLineCurrent
 hi default link BufTabLineModifiedActive  BufTabLineActive
@@ -55,6 +59,23 @@ function s:SID()
 	return matchstr(expand('<sfile>'), '<SNR>\d\+_')
 endfunction
 
+let s:mru_list = []
+function! buftabline#updatebuf()
+	let l:bufnums = buftabline#user_buffers()
+	let l:cur_buf = bufnr('%')
+	if len(l:bufnums) > 0 && index(l:bufnums, l:cur_buf) != -1
+		if len(s:mru_list) == 0
+			let s:mru_list = l:bufnums
+		endif
+
+		let s:mru_list = add(filter(s:mru_list, 'v:val != l:cur_buf'), l:cur_buf)
+		if len(s:mru_list) > g:buftabline_plug_max
+			let s:mru_list = s:mru_list[-g:buftabline_plug_max:]
+		endif
+	endif
+	return filter(l:bufnums, 'index(s:mru_list, v:val) != -1')
+endfunction
+
 let s:dirsep = fnamemodify(getcwd(),':p')[-1:]
 let s:centerbuf = winbufnr(0)
 let s:tablineat = has('tablineat')
@@ -63,40 +84,42 @@ function! buftabline#render()
 	let show_num = g:buftabline_numbers == 1
 	let show_ord = g:buftabline_numbers == 2
 	let show_mod = g:buftabline_indicators
-	let lpad     = g:buftabline_separators ? nr2char(0x23B8) : ' '
+	" let lpad     = g:buftabline_separators ? nr2char(0x23B8) : ' '
+	" https://en.wikibooks.org/wiki/Unicode/List_of_useful_symbols
+	let lpad     = g:buftabline_separators ? ' ' . nr2char(0x00A7) : ' '
 
-	let bufnums = buftabline#user_buffers()
+	let bufnums = buftabline#updatebuf()
 	let centerbuf = s:centerbuf " prevent tabline jumping around when non-user buffer current (e.g. help)
 
 	" pick up data on all the buffers
 	let tabs = []
 	let path_tabs = []
 	let tabs_per_tail = {}
-	let currentbuf = winbufnr(0)
+	let currentbuf = len(s:mru_list) > 0 ? s:mru_list[-1] : winbufnr(0)
+	let lastbuf = len(s:mru_list) > 1 ? s:mru_list[-2] : -1
 	let screen_num = 0
 	for bufnum in bufnums
-		let screen_num = show_num ? bufnum : show_ord ? screen_num + 1 : ''
+		let screen_num = show_num ? bufnum : show_ord ? (screen_num + 1) : ''
 		let tab = { 'num': bufnum, 'pre': '' }
-		let tab.hilite = currentbuf == bufnum ? 'Current' : bufwinnr(bufnum) > 0 ? 'Active' : 'Hidden'
+		let tab.hilite = currentbuf == bufnum ? 'Current' : lastbuf == bufnum ? 'Active' : 'Hidden'
+		if strlen(screen_num) | let tab.pre = screen_num . '.' | endif
 		if currentbuf == bufnum | let [centerbuf, s:centerbuf] = [bufnum, bufnum] | endif
 		let bufpath = bufname(bufnum)
 		if strlen(bufpath)
 			let tab.path = fnamemodify(bufpath, ':p:~:.')
 			let tab.sep = strridx(tab.path, s:dirsep, strlen(tab.path) - 2) " keep trailing dirsep
-			let tab.label = tab.path[tab.sep + 1:]
-			let pre = screen_num
+			let tab.label = currentbuf == bufnum ? tab.path : tab.path[tab.sep + 1:]
 			if getbufvar(bufnum, '&mod')
 				let tab.hilite = 'Modified' . tab.hilite
-				if show_mod | let pre = '+' . pre | endif
+				if show_mod | let tab.label = '+' . tab.label | endif
 			endif
-			if strlen(pre) | let tab.pre = pre . ' ' | endif
 			let tabs_per_tail[tab.label] = get(tabs_per_tail, tab.label, 0) + 1
 			let path_tabs += [tab]
 		elseif -1 < index(['nofile','acwrite'], getbufvar(bufnum, '&buftype')) " scratch buffer
 			let tab.label = ( show_mod ? '!' . screen_num : screen_num ? screen_num . ' !' : '!' )
 		else " unnamed file
 			let tab.label = ( show_mod && getbufvar(bufnum, '&mod') ? '+' : '' )
-			\             . ( screen_num ? screen_num : '*' )
+			\             . ' * --NO NAME--' . localtime()
 		endif
 		let tabs += [tab]
 	endfor
@@ -121,10 +144,11 @@ function! buftabline#render()
 
 	" 2. sum the string lengths for the left and right halves
 	let currentside = lft
-	let lpad_width = strwidth(lpad)
 	for tab in tabs
-		let tab.width = lpad_width + strwidth(tab.pre) + strwidth(tab.label) + 1
-		let tab.label = lpad . tab.pre . substitute(strtrans(tab.label), '%', '%%', 'g') . ' '
+		let bufnum =  (strlen(tab.pre) && show_ord) ? ('[b' . tab.num . ']') : ''
+		let tab.width = strwidth(lpad) + strwidth(tab.pre) + strwidth(bufnum) + strwidth(tab.label) + 1
+		let tab.label = "%#BufTabLineTabPad#" . lpad . tab.pre . '%#BufTabLineBufnum#' . bufnum
+					\ . "%#BufTabLine" . tab.hilite . "#" . substitute(strtrans(tab.label), '%', '%%', 'g') . ' '
 		if centerbuf == tab.num
 			let halfwidth = tab.width / 2
 			let lft.width += halfwidth
@@ -160,12 +184,14 @@ function! buftabline#render()
 		endfor
 	endif
 
-	if len(tabs) | let tabs[0].label = substitute(tabs[0].label, lpad, ' ', '') | endif
+	" if len(tabs) | let tabs[0].label = substitute(tabs[0].label, lpad, ' ', '') | endif
 
 	let swallowclicks = '%'.(1 + tabpagenr('$')).'X'
 	return s:tablineat
-		\ ? join(map(tabs,'"%#BufTabLine".v:val.hilite."#" . "%".v:val.num."@'.s:sid.'switch_buffer@" . strtrans(v:val.label)'),'') . '%#BufTabLineFill#' . swallowclicks
-		\ : swallowclicks . join(map(tabs,'"%#BufTabLine".v:val.hilite."#" . strtrans(v:val.label)'),'') . '%#BufTabLineFill#'
+		\ ? join(map(tabs,
+			\ '"%".v:val.num."@'.s:sid.'switch_buffer@" . strtrans(v:val.label)'
+			\ ),'') . '%#BufTabLineFill#' . swallowclicks
+		\ : swallowclicks . join(map(tabs, 'strtrans(v:val.label)'), '') . '%#BufTabLineFill#'
 endfunction
 
 function! buftabline#update(zombie)
@@ -194,11 +220,22 @@ autocmd FileType qf call buftabline#update(0)
 autocmd BufDelete * call buftabline#update(str2nr(expand('<abuf>')))
 augroup END
 
-for s:n in range(1, g:buftabline_plug_max) + ( g:buftabline_plug_max > 0 ? [-1] : [] )
-	let s:b = s:n == -1 ? -1 : s:n - 1
-	execute printf("noremap <silent> <Plug>BufTabLine.Go(%d) :<C-U>exe 'b'.get(buftabline#user_buffers(),%d,'')<cr>", s:n, s:b)
-endfor
-unlet! s:n s:b
+command! -bang -nargs=* BufTablineGoto   call buftabline#action(0, '<bang>'=='!', <f-args>)
+command! -bang -nargs=* BufTablineRemove call buftabline#action(1, '<bang>'=='!', <f-args>)
+" action: 0 jump, >0 bd delete buffer
+function! buftabline#action(action, bang, ...)
+	let l:valid_bufnums = filter(buftabline#user_buffers(), 'index(s:mru_list, v:val) != -1')
+	if a:0 == 0
+		if len(l:valid_bufnums) > 1 && a:action > 0
+			exec 'silent! bd' . (a:bang ? '! ' : '')
+		endif
+	else
+		let l:bufnums = map(copy(a:000),'v:val =~ ''\d\+'' ? v:val + 0 : v:val')
+		for l:bufnum in filter(l:bufnums, 'v:val > 0 && v:val <= len(l:valid_bufnums)')
+			exec 'silent! ' . (a:action > 0 ? 'bd' : 'b') . (a:bang ? '! ' : ' ') . l:valid_bufnums[l:bufnum-1]
+		endfor
+	endif
+endfunction
 
 if v:version < 703
 	function s:transpile()
