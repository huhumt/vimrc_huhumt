diff --git a/plugin/buftabline.vim b/plugin/buftabline.vim
index 81ef326..cd2975d 100644
--- a/plugin/buftabline.vim
+++ b/plugin/buftabline.vim
@@ -2,17 +2,17 @@
 " Licence:     The MIT License (MIT)
 " Commit:      $Format:%H$
 " {{{ Copyright (c) 2015 Aristotle Pagaltzis <pagaltzis@gmx.de>
-" 
+"
 " Permission is hereby granted, free of charge, to any person obtaining a copy
 " of this software and associated documentation files (the "Software"), to deal
 " in the Software without restriction, including without limitation the rights
 " to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 " copies of the Software, and to permit persons to whom the Software is
 " furnished to do so, subject to the following conditions:
-" 
+"
 " The above copyright notice and this permission notice shall be included in
 " all copies or substantial portions of the Software.
-" 
+"
 " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -29,10 +29,14 @@ endif
 
 scriptencoding utf-8
 
-hi default link BufTabLineCurrent         TabLineSel
-hi default link BufTabLineActive          PmenuSel
-hi default link BufTabLineHidden          TabLine
-hi default link BufTabLineFill            TabLineFill
+" https://www.ditig.com/256-colors-cheat-sheet
+highlight BufTabLineTabPad                       ctermbg=235   ctermfg=76
+highlight BufTabLineBufnum    cterm=bold         ctermbg=142   ctermfg=126
+highlight BufTabLineCurrent   cterm=underline    ctermbg=12    ctermfg=120
+highlight BufTabLineActive                       ctermbg=3     ctermfg=110
+highlight BufTabLineHidden                       ctermbg=238   ctermfg=223
+
+hi default link BufTabLineFill            BufTabLineHidden
 hi default link BufTabLineModifiedCurrent BufTabLineCurrent
 hi default link BufTabLineModifiedActive  BufTabLineActive
 hi default link BufTabLineModifiedHidden  BufTabLineHidden
@@ -44,7 +48,7 @@ let g:buftabline_show       = get(g:, 'buftabline_show',       2)
 let g:buftabline_plug_max   = get(g:, 'buftabline_plug_max',  10)
 
 function! buftabline#user_buffers() " help buffers are always unlisted, but quickfix buffers are not
-	return filter(range(1,bufnr('$')),'buflisted(v:val) && "quickfix" !=? getbufvar(v:val, "&buftype")')
+	return filter(range(1,bufnr('$')),'&ft!=# "netrw" && buflisted(v:val) && "quickfix" !=? getbufvar(v:val, "&buftype")')
 endfunction
 
 function! s:switch_buffer(bufnum, clicks, button, mod)
@@ -55,48 +59,74 @@ function s:SID()
 	return matchstr(expand('<sfile>'), '<SNR>\d\+_')
 endfunction
 
+let s:mru_list = []
+function! buftabline#updatebuf()
+	let l:bufnums = buftabline#user_buffers()
+	let l:cur_buf = bufnr('%')
+	if len(l:bufnums) > 0 && index(l:bufnums, l:cur_buf) != -1
+		if len(s:mru_list) == 0
+			let s:mru_list = l:bufnums
+		endif
+
+		let s:mru_list = add(filter(s:mru_list, 'v:val != l:cur_buf'), l:cur_buf)
+		if len(s:mru_list) > g:buftabline_plug_max
+			let s:mru_list = s:mru_list[-g:buftabline_plug_max:]
+		endif
+	endif
+	return filter(l:bufnums, 'index(s:mru_list, v:val) != -1')
+endfunction
+
 let s:dirsep = fnamemodify(getcwd(),':p')[-1:]
-let s:centerbuf = winbufnr(0)
 let s:tablineat = has('tablineat')
 let s:sid = s:SID() | delfunction s:SID
 function! buftabline#render()
 	let show_num = g:buftabline_numbers == 1
 	let show_ord = g:buftabline_numbers == 2
 	let show_mod = g:buftabline_indicators
-	let lpad     = g:buftabline_separators ? nr2char(0x23B8) : ' '
+	" let lpad     = g:buftabline_separators ? nr2char(0x23B8) : ' '
+	" https://en.wikibooks.org/wiki/Unicode/List_of_useful_symbols
+	let lpad     = g:buftabline_separators ? ' ' . nr2char(0x00A7) : ' '
+	let bufnums  = buftabline#updatebuf()
 
-	let bufnums = buftabline#user_buffers()
-	let centerbuf = s:centerbuf " prevent tabline jumping around when non-user buffer current (e.g. help)
+	if len(bufnums) == 0
+		set showtabline=1
+		return
+	endif
 
 	" pick up data on all the buffers
 	let tabs = []
 	let path_tabs = []
 	let tabs_per_tail = {}
-	let currentbuf = winbufnr(0)
+	let currentbuf = len(s:mru_list) > 0 ? s:mru_list[-1] : winbufnr(0)
+	let current_tab_index = 0
+	let lastbuf = len(s:mru_list) > 1 ? s:mru_list[-2] : -1
 	let screen_num = 0
 	for bufnum in bufnums
-		let screen_num = show_num ? bufnum : show_ord ? screen_num + 1 : ''
-		let tab = { 'num': bufnum, 'pre': '' }
-		let tab.hilite = currentbuf == bufnum ? 'Current' : bufwinnr(bufnum) > 0 ? 'Active' : 'Hidden'
-		if currentbuf == bufnum | let [centerbuf, s:centerbuf] = [bufnum, bufnum] | endif
+		let screen_num = show_num ? bufnum : show_ord ? (screen_num + 1) : ''
+		let tab = { 'num': bufnum, 'pre': strlen(screen_num) ? screen_num . '.' : '' }
+		if currentbuf == bufnum
+			let tab.hilite = 'Current'
+			let current_tab_index = index(bufnums, bufnum)
+			let tab.num .= '*'
+		else
+			let tab.hilite = lastbuf == bufnum ? 'Active' : 'Hidden'
+		endif
 		let bufpath = bufname(bufnum)
 		if strlen(bufpath)
 			let tab.path = fnamemodify(bufpath, ':p:~:.')
 			let tab.sep = strridx(tab.path, s:dirsep, strlen(tab.path) - 2) " keep trailing dirsep
 			let tab.label = tab.path[tab.sep + 1:]
-			let pre = screen_num
 			if getbufvar(bufnum, '&mod')
 				let tab.hilite = 'Modified' . tab.hilite
-				if show_mod | let pre = '+' . pre | endif
+				if show_mod | let tab.label = '+' . tab.label | endif
 			endif
-			if strlen(pre) | let tab.pre = pre . ' ' | endif
 			let tabs_per_tail[tab.label] = get(tabs_per_tail, tab.label, 0) + 1
 			let path_tabs += [tab]
 		elseif -1 < index(['nofile','acwrite'], getbufvar(bufnum, '&buftype')) " scratch buffer
 			let tab.label = ( show_mod ? '!' . screen_num : screen_num ? screen_num . ' !' : '!' )
 		else " unnamed file
 			let tab.label = ( show_mod && getbufvar(bufnum, '&mod') ? '+' : '' )
-			\             . ( screen_num ? screen_num : '*' )
+			\             . ' * --NO NAME--' . localtime()
 		endif
 		let tabs += [tab]
 	endfor
@@ -113,59 +143,32 @@ function! buftabline#render()
 		endfor
 	endwhile
 
-	" now keep the current buffer center-screen as much as possible:
-
-	" 1. setup
-	let lft = { 'lasttab':  0, 'cut':  '.', 'indicator': '<', 'width': 0, 'half': &columns / 2 }
-	let rgt = { 'lasttab': -1, 'cut': '.$', 'indicator': '>', 'width': 0, 'half': &columns - lft.half }
-
 	" 2. sum the string lengths for the left and right halves
-	let currentside = lft
-	let lpad_width = strwidth(lpad)
+	let total_width = 0
 	for tab in tabs
-		let tab.width = lpad_width + strwidth(tab.pre) + strwidth(tab.label) + 1
-		let tab.label = lpad . tab.pre . substitute(strtrans(tab.label), '%', '%%', 'g') . ' '
-		if centerbuf == tab.num
-			let halfwidth = tab.width / 2
-			let lft.width += halfwidth
-			let rgt.width += tab.width - halfwidth
-			let currentside = rgt
-			continue
-		endif
-		let currentside.width += tab.width
+		let bufnum =  (strlen(tab.pre) && show_ord) ? ('[b' . tab.num . ']') : ''
+		let tab.width = strwidth(lpad) + strwidth(tab.pre) + strwidth(bufnum) + strwidth(tab.label) + 1
+		let total_width += tab.width
+		let tab.label = "%#BufTabLineTabPad#" . lpad . tab.pre . '%#BufTabLineBufnum#' . bufnum
+					\ . "%#BufTabLine" . tab.hilite . "#" . substitute(strtrans(tab.label), '%', '%%', 'g') . ' '
 	endfor
-	if currentside is lft " centered buffer not seen?
-		" then blame any overflow on the right side, to protect the left
-		let [lft.width, rgt.width] = [0, lft.width]
-	endif
-
-	" 3. toss away tabs and pieces until all fits:
-	if ( lft.width + rgt.width ) > &columns
-		let oversized
-		\ = lft.width < lft.half ? [ [ rgt, &columns - lft.width ] ]
-		\ : rgt.width < rgt.half ? [ [ lft, &columns - rgt.width ] ]
-		\ :                        [ [ lft, lft.half ], [ rgt, rgt.half ] ]
-		for [side, budget] in oversized
-			let delta = side.width - budget
-			" toss entire tabs to close the distance
-			while delta >= tabs[side.lasttab].width
-				let delta -= remove(tabs, side.lasttab).width
-			endwhile
-			" then snip at the last one to make it fit
-			let endtab = tabs[side.lasttab]
-			while delta > ( endtab.width - strwidth(strtrans(endtab.label)) )
-				let endtab.label = substitute(endtab.label, side.cut, '', '')
-			endwhile
-			let endtab.label = substitute(endtab.label, side.cut, side.indicator, '')
-		endfor
-	endif
 
-	if len(tabs) | let tabs[0].label = substitute(tabs[0].label, lpad, ' ', '') | endif
+	let right_iters = range(len(tabs) - 1, current_tab_index + 1, -1)
+	let left_iters = range(0, current_tab_index - 1)
+	let remove_order_iters = filter(right_iters + left_iters, 'tabs[v:val].hilite =~# "Hidden"')
+	let delta = total_width - &columns
+	let remove_idx = 0
+	while delta > 0
+		let delta -= remove(tabs, remove_order_iters[remove_idx]).width
+		let remove_idx += 1
+	endwhile
 
 	let swallowclicks = '%'.(1 + tabpagenr('$')).'X'
 	return s:tablineat
-		\ ? join(map(tabs,'"%#BufTabLine".v:val.hilite."#" . "%".v:val.num."@'.s:sid.'switch_buffer@" . strtrans(v:val.label)'),'') . '%#BufTabLineFill#' . swallowclicks
-		\ : swallowclicks . join(map(tabs,'"%#BufTabLine".v:val.hilite."#" . strtrans(v:val.label)'),'') . '%#BufTabLineFill#'
+		\ ? join(map(tabs,
+			\ '"%".v:val.num."@'.s:sid.'switch_buffer@" . strtrans(v:val.label)'
+			\ ),'') . '%#BufTabLineFill#' . swallowclicks
+		\ : swallowclicks . join(map(tabs, 'strtrans(v:val.label)'), '') . '%#BufTabLineFill#'
 endfunction
 
 function! buftabline#update(zombie)
@@ -197,11 +200,28 @@ autocmd FileType qf call buftabline#update(0)
 autocmd BufDelete * call buftabline#update(str2nr(expand('<abuf>')))
 augroup END
 
-for s:n in range(1, g:buftabline_plug_max) + ( g:buftabline_plug_max > 0 ? [-1] : [] )
-	let s:b = s:n == -1 ? -1 : s:n - 1
-	execute printf("noremap <silent> <Plug>BufTabLine.Go(%d) :<C-U>exe 'b'.get(buftabline#user_buffers(),%d,'')<cr>", s:n, s:b)
-endfor
-unlet! s:n s:b
+command! -bang -nargs=* BufTablineGoto   call buftabline#action(0, '<bang>'=='!', <f-args>)
+command! -bang -nargs=* BufTablineRemove call buftabline#action(1, '<bang>'=='!', <f-args>)
+" action: 0 jump, >0 bd delete buffer
+function! buftabline#action(action, bang, ...)
+	let l:valid_bufnums = filter(buftabline#user_buffers(), 'index(s:mru_list, v:val) != -1')
+	if a:0 == 0
+		if len(l:valid_bufnums) > 1 && a:action > 0
+			exec 'silent! bd' . (a:bang ? '! ' : '')
+		endif
+	else
+		let l:bufnums = map(copy(a:000),'v:val =~ ''\d\+'' ? v:val + 0 : v:val')
+		if a:action > 0
+		    let l:bd_bufs = uniq(sort(filter(l:bufnums, 'v:val > 0 && v:val <= len(l:valid_bufnums)')))
+			if len(l:valid_bufnums) > 1 && !empty(l:bd_bufs)
+				exec 'silent! bd' (a:bang ? '! ' : ' ') . join(map(l:bd_bufs, 'l:valid_bufnums[v:val-1]'), " ")
+			endif
+		else
+			let l:idx = l:bufnums[-1] > len(l:valid_bufnums) ? -1 : (l:bufnums[-1] > 0 ? l:bufnums[-1] - 1 : 0)
+			exec 'silent! b' (a:bang ? '! ' : ' ') . l:valid_bufnums[l:idx]
+		endif
+	endif
+endfunction
 
 if v:version < 703
 	function s:transpile()
